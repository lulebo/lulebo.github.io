<!DOCTYPE html>
<html lang="en-US">
<html>
<head>
    <meta charset="UTF-8">
    <title>MP4 H264 Analyzer</title>
    <meta name="description" content="Analyze MP4 files in your browser. Frame information, GOP structure and bitrate is presented in a nice graph.">
    <!-- Global site tag (gtag.js) - Google Analytics -->
		<script async src="https://www.googletagmanager.com/gtag/js?id=G-6MQJ3CTV09"></script>
		<script>
		  window.dataLayer = window.dataLayer || [];
		  function gtag(){dataLayer.push(arguments);}
		  gtag('js', new Date());

		  gtag('config', 'G-6MQJ3CTV09');
		</script>
    <script type="text/javascript" src="canvasjs.js"></script></head>
    <body>
        <center><h1 id="title">MP4 Analyzer</h1>
		<canvas hidden=true id="preview" width="533" height="300" style="border:1px solid #000000;"></canvas>
            <p>Drop an MP4/MOV file with H264 encoding on this page</p>
        </center>

        <div id="chartContainer" style="height: 300px; width: 100%;"><center><p><div style="width: 300px;">Should work for most MP4 files containing h264/avc video. Does not handle fragmented MP4s. Might have other issues with strange MP4 flavors.<br><br>Should now parse Profile and Level correctly for most files<br><br>Will show preview of I-frames on supported browsers</div></p></center></p></div>
    <div id="SEIContainer"></div>

        <center><p><font color="red">IDR frame</font><br/><font color="orange">I frame</font><br/><font color="blue">P frame</font><br/><font color="Green">B frame</font><br/></p><p>Version 0.5, by Carl Lindqvist 2022</p>
          <p>@NESNioreh</p>
        </center>

<script>

var decoderExists = false;
var decoder;
var aspect = 1.777777;
var pixelWidth = 0;
var pixelHeight = 0;

var seqParamSet;

var canvas = document.querySelector("canvas");
//canvas.width=1920;
//canvas.height=1080;
//var offscreen = canvas.transferControlToOffscreen();
//document.body.appendChild(canvas);
let ctx = canvas.getContext('2d');

	async function initdecoder(){
		if ('VideoEncoder' in window) {
		  console.log("VideoEncoder is supported");

		  const config = {
			  codec: "avc1.640034",
			  description: seqParamSet
			};

		  const init = {
			  output: handleFrame,
			  error: (e) => {
				console.log(e);
			  },
			};

		  decoder = new VideoDecoder(init);
		  decoder.configure(config);

		  decoderExists = true;

		  canvas.width = canvas.height*aspect;
		  canvas.hidden = false;

		  //Try to decode first frame
		  handleMouseMove({dataPoint: {x:0}});

		}else{
		  console.log("No VideoEncoder support :(");
		}
	}

	function handleFrame(frame) {
		//console.log("Frame arrived decoded");

		ctx.drawImage(frame, 0, 0, canvas.width, canvas.height);

		// Close ASAP.
		frame.close();

		gtag('event', 'show_iframe', {
			  'event_category' : 'engagement',
			  'event_label' : 'View preview of I-frame'
			});

	}

	//Assume first frame is IDR
	var lastKeyFrame = 0;


	var lastMouseOverX = -1;
	function handleMouseMove(e){
		//console.log(e);
		dataPoint = e.dataPoint;

		if(dataPoint.x == lastMouseOverX) return;
		lastMouseOverX = dataPoint.x;

		if(frameList[dataPoint.x].keyFrame){
			decodeChunk(new Uint8Array(data, frameList[dataPoint.x].startOffset, frameList[dataPoint.x].size));
			lastKeyFrame=dataPoint.x;
		}
		//After flush, needs to decode IDR frame before any other frame, including I.
		else if(frameList[dataPoint.x].frameType == "I"){
			decodeChunk(new Uint8Array(data, frameList[lastKeyFrame].startOffset, frameList[lastKeyFrame].size));
			decodeChunk(new Uint8Array(data, frameList[dataPoint.x].startOffset, frameList[dataPoint.x].size));
		}

		decoder.flush();
	}

	function decodeChunk(chunkData){

		if(!decoderExists)return;

		const chunk = new EncodedVideoChunk({
			//timestamp: new Date().getTime(),
			timestamp: 0,
			type: "key",
			data: chunkData,
		  });

		  decoder.decode(chunk);

	}

	function calculateGOPsize(){

		let gopDurations = [];

		let lastKeyFrame=0;
		for ( var i = 1; i < frameList.length; i++){
			if (frameList[i].keyFrame){
				gopDurations.push(i-lastKeyFrame);
				lastKeyFrame = i;
			}
		}

		gopDurations = gopDurations.sort((a, b) => (b - a));

		if(gopDurations.length == 0) return -1;

		let gopDifferent = false;
		let firstGopDur = gopDurations[0];
		for(var i = 1; i < gopDurations.length; i++){
			if (gopDurations[i] != firstGopDur){
				//Not all gops the same. Need to check for extra keyframes later
				gopDifferent = true;
				console.log("GOP size not the same at gopDuration[" + i + "]");
			}
		}

		if(gopDifferent == false) return firstGopDur;

		if(gopDurations.length > 8){
			if(gopDurations[0] == gopDurations[Math.floor(gopDurations.length/2)]){
				return gopDurations[0];
			}
		}

		return -1;
	}

	function findExtraKeyframes(){
		let extraKeyFrames = [];

		if (gopSize == -1) return extraKeyFrames;

		for( var i = 0; i < frameList.length; i++){

			if( frameList[i].keyFrame && i % gopSize!=0 ){
				extraKeyFrames.push(frameList[i]);
			}
		}

		return extraKeyFrames;
	}


    var chartContainer = document.getElementById('chartContainer');

	function frameToTimestamp(frame, framerate){
		var seconds = frame / framerate;
		var minutes = seconds / 60;
		var hours = Math.floor(minutes / 60);
		var milliseconds = Math.floor(((frame % framerate)/framerate)*1000);
		seconds = Math.floor(seconds % 60);
		minutes = Math.floor(minutes % 60);

		return "" + ("0" + hours).slice(-2) + ":" +("0" + minutes).slice(-2) + ":" + ("0" + seconds).slice(-2) + ":" + ("00" + milliseconds).slice(-3);
	}

    function drawVideoChart(frameList) {
       var totalSize = 0;
       var bitrate = [];
       var columnColors = [];
       var pts = [];
       var dts = [];
	   var GOPbitrate = [];

       for (var i = 0; i < frameList.length; i++) {
	       var frameSize = frameList[i].size;
           bitrate.push(frameSize);
		   totalSize += frameSize;

           if (frameList[i].frameType == "I" || frameList[i].frameType == "SI") {
               if (frameList[i].keyFrame) {
                   columnColors.push("Red");
				   GOPbitrate.push({frame: i, size: 0, gopFrameLength: 0});
               } else {
                   columnColors.push("Orange");
               }
           } else if (frameList[i].frameType == "P" || frameList[i].frameType == "SP") {
               columnColors.push("Blue");
           } else if (frameList[i].frameType == "B") {
               columnColors.push("Green");
           } else {
               //Unknown frameType
               columnColors.push("Black");
           }

           pts.push(frameList[i].pts);
           dts.push(frameList[i].streamOrder);

		   GOPbitrate[GOPbitrate.length - 1].size += frameSize;
		   GOPbitrate[GOPbitrate.length - 1].gopFrameLength += 1;
       }

	   var lastPts = pts[pts.length-1];
	   var frameCount = pts.length;

	   var frameRate = (1.00 * timeScale)/((1.00 * lastPts)/frameCount);
	   console.log("Framerate: " + frameRate);

	   //plot the frames
       var data = [];
       var dataSeries = {
           type: "column",
           toolTipContent: "Frame: {x}<br>Bytes: {y}<br>PTS: {pts}<br>Decode order: {dts}<br>Timestamp: {time}"
       };
       var dataPoints = [];
       for (var i = 0; i < bitrate.length; i += 1) {
           dataPoints.push({
               x: i,
               y: bitrate[i],
               color: columnColors[i],
               pts: pts[i],
               dts: dts[i],
			   time: frameToTimestamp(pts[i]-pts[0],timeScale)
           });
       }
       dataSeries.dataPoints = dataPoints;
       //data.push(dataSeries);

	   //plot the bitrate
	   var dataSeries2 = {
	       type: "splineArea",
		   color: "rgba(54,158,173,.7)",
		   toolTipContent: "Bitrate: {y}kbps"
	   }
	   var dataPoints2 = [];
	   for (var i = 0; i < GOPbitrate.length; i++) {
	       dataPoints2.push({
		       x: GOPbitrate[i].frame,
			   y: Math.round(GOPbitrate[i].size*8/1000/(GOPbitrate[i].gopFrameLength/frameRate))
		   });
	   }
	   dataSeries2.dataPoints = dataPoints2;
	   dataSeries2.axisYType = "secondary";
	   data.push(dataSeries2);
       data.push(dataSeries);

	   dataSeries.mousemove= function(e){
	    handleMouseMove(e);
	   };

       var chart = new CanvasJS.Chart("chartContainer", {
           zoomEnabled: true,
           panEnabled: true,
           title: {
               text: "GOP Structure"
           },
           legend: {
               horizontalAlign: "right",
               verticalAlign: "center"
           },
           axisY: {
               includeZero: true,
			   title: "Frame size (bytes)"
           },
		   axisY2: {
               includeZero: true,
			   title: "Bitrate (kbps)"
           },
           data: data,
       });

       var avgBitrate = Math.round((totalSize / (pts.length / frameRate)) * 8 / 1000);

	   if(SEI != "") SEI = "<p>SEI data: "+SEI+"</p>";

	   if(h264Profile != "") h264Profile = "<p>"+h264Profile+", level "+h264Level+"</p>";

	   if(h264RefFrames != "") h264RefFrames = "<p>Number of ref frames signalled in bitstream: "+h264RefFrames+"</p>";

	   let gopSizeString ="<p>No fixed keyframe distance detected</p>";

	   if(gopSize>0){
		gopSizeString = "<p>Keyframe distance: " + gopSize + " frames</p>";
	   }

	   let extraKeyframesString = "";
	   if(extraKeyFrames.length>0){

			extraKeyframesString += "<p>Extra keyframes detected at:<br>";

			for(var i = 0; i < extraKeyFrames.length; i++){
				let framePts = extraKeyFrames[i].pts;
				extraKeyframesString += "Frame " + extraKeyFrames[i].streamOrder + ", " + frameToTimestamp(framePts-pts[0],timeScale) +"<br>";
			}

			extraKeyframesString +="</p>";
	   }

       SEIContainer.innerHTML="<center>" + h264Profile + h264RefFrames + SEI + "<p>Frame rate: "+frameRate+"<br>Resolution: " + pixelWidth + "x" + pixelHeight + "</p>" + gopSizeString + extraKeyframesString + "<p>Average bitrate: "+avgBitrate+"kbps</p></center>";

       chart.render();


   }



   var data;

   var frameList = [];
   var SEI = "";
   var SEIContainer = document.getElementById('SEIContainer');
   var title = document.getElementById('title');

   var h264Profile = "";
   var h264Level = "";
   var h264RefFrames = "";
   var gopSize = -1;
   var extraKeyFrames = [];


   var exampleFrame = {
       streamOrder: 75,
       size: 12345,
       frameType: "I",
       pts: 512
   }

   function sortByPts(a, b) {
       return parseFloat(a.pts) - parseFloat(b.pts);
   }

   //var dropZone = document.getElementById('dropZone');
   var dropZone = document.body;

   // Optional.   Show the copy icon when dragging over.  Seems to only work for chrome.
   dropZone.addEventListener('dragover', function(e) {
       e.stopPropagation();
       e.preventDefault();
       e.dataTransfer.dropEffect = 'copy';
   });

   function u8toString(u8) {
       return String.fromCharCode.apply(null, u8);
   }

   function createHexString(arr) {
       var result = "";

       for (var i = 0; i < arr.length; i++) {
           result += arr[i].toString(16);
       }

       return result;
   }

   function parseSEIData(offset) {

       var NALtype = (new Uint8Array(data, offset + 4, 1))[0];
       if (Number(NALtype & 0x1F) != 6) {
           console.log("Not SEI NAL type");
           return false;
       }


       var SEItype = (new Uint8Array(data, offset + 5, 1))[0];

       if (Number(SEItype) == 5) {
           console.log("Found User data unregistered SEI message")

           var _position = 6;

           var payloadSize = 0;
           var payloadSizeByte;
           do {
               payloadSizeByte = Number((new Uint8Array(data, offset + _position, 1))[0]);
               payloadSize = payloadSize + Number(payloadSizeByte);
               _position++;
           } while (Number(payloadSizeByte) == 255);

           console.log("SEI Payload Size is " + payloadSize);

           var _uuid = createHexString(new Uint8Array(data, offset + _position, 16));
           _position += 16;

           console.log("UUID: " + _uuid);

           var messageLength = payloadSize - _position;

           if(messageLength>0){

               console.log("Message:");

               SEI = u8toString(new Uint8Array(data, offset + _position, messageLength));
               console.log(SEI);
           }else{
               SEI = "Unable to parse SEI data";
               console.log("Unable to parse SEI data");
               console.log(messageLength);
           }

       }



       return false;
   }

   function readBits(arr, pos, bits) {

       if (bits == 0) {
           return 0;
       }

       var result = "";

       for (var i = 0; i < bits; i++) {

           arrPos = Math.floor((pos + i) / 8);
           _pos = (pos + i) % 8;

           var bit = Number(new Uint8Array([arr[arrPos] << _pos])[0] >> 7);

           result = result + bit;
       }
       return parseInt(result, 2);

   }

   //Takes uint8Array and a bit posistion, returns parsed number in [0], number of bits read in [1]
   function parseExpGolomb(arr, pos) {

       var totalBits = 0;

       var readBits = function(bits) {

           if (bits == 0) {
               return 0;
           }

           totalBits += bits;

           var result = "";

           for (var i = 0; i < bits; i++) {
               arrPos = Math.floor((pos + i) / 8);
               _pos = (pos + i) % 8;

               var bit = Number(new Uint8Array([arr[arrPos] << _pos])[0] >> 7);

               result = result + bit;
           }
           pos = pos + bits;
           return parseInt(result, 2);
       }

       var leadingZeroBits = -1;

       for (var b = 0; b == 0; leadingZeroBits++) {
           b = readBits(1);
       }

       var value = Math.pow(2, leadingZeroBits) - 1 + readBits(leadingZeroBits);

       return [value, totalBits];

   }

   function parseSliceHeader(offset,) {
       var rawData = new Uint8Array(data, offset, 32);
       var bitOffset = 0;

       var parseTemp = parseExpGolomb(rawData, bitOffset);
       var firstMbInSlice = parseTemp[0];
       bitOffset += parseTemp[1];

       parseTemp = parseExpGolomb(rawData, bitOffset);
       var sliceType = parseTemp[0];
       bitOffset += parseTemp[1];

       /*
	   parseTemp = parseExpGolomb(rawData, bitOffset);
       var pictParameterSetId = parseTemp[0];
       bitOffset += parseTemp[1];

	   parseTemp = parseExpGolomb(rawData, bitOffset);
	   var frameNum = parseTemp[0];
       bitOffset += parseTemp[1];
	   */

	   //console.log("pictParameterSetId in slice header: "+pictParameterSetId);


       /*
       slice_type Name of slice_type
       0 P (P slice)
       1 B (B slice)
       2 I (I slice)
       3 SP (SP slice)
       4 SI (SI slice)
       5 P (P slice)
       6 B (B slice)
       7 I (I slice)
       8 SP (SP slice)
       9 SI (SI slice)
       */

       var frameType = sliceType;
       if (sliceType == 0) {
           frameType = "P";
       }
       if (sliceType == 1) {
           frameType = "B";
       }
       if (sliceType == 2) {
           frameType = "I";
       }
       if (sliceType == 3) {
           frameType = "SP";
       }
       if (sliceType == 4) {
           frameType = "SI";
       }
       if (sliceType == 5) {
           frameType = "P";
       }
       if (sliceType == 6) {
           frameType = "B";
       }
       if (sliceType == 7) {
           frameType = "I";
       }
       if (sliceType == 8) {
           frameType = "SP";
       }
       if (sliceType == 9) {
           frameType = "SI";
       }


       //console.log("Slice type: " + frameType + ", FrameNum: " +frameNum);

       return {
           frameType: frameType
       }

   }

   //var slices = 1;

   function parsePicParameterSetRbsp(offset){

		/*
		 pic_parameter_set_id 1 ue(v)
		 seq_parameter_set_id 1 ue(v)
		 entropy_coding_mode_flag 1 u(1)
		 pic_order_present_flag 1 u(1)
		 num_slice_groups_minus1 1 ue(v)
		*/

		//console.log("Found pict_parameter_set_rbsp");

		var rawData = new Uint8Array(data, offset, 32);
		var bitOffset = 0;

		var parseTemp = parseExpGolomb(rawData, bitOffset);
		var pic_parameter_set_id = parseTemp[0];
		bitOffset += parseTemp[1];

		console.log("pic_parameter_set_id: " + pic_parameter_set_id);

		parseTemp = parseExpGolomb(rawData, bitOffset);
		var seq_parameter_set_id = parseTemp[0];
		bitOffset += parseTemp[1];

		console.log("seq_parameter_set_id: " + seq_parameter_set_id);

		bitOffset += 2;

		parseTemp = parseExpGolomb(rawData, bitOffset);
		var slices = parseTemp[0];

		console.log("Slices minus 1: " + slices);

   }

	function parseSeqParameterSetRbsp(offset){
		console.log("Parsing seqParameterSet");

		var rawData = new Uint8Array(data, offset + 3, 64);
		var bitOffset = 0;

		var hex = new Uint8Array(data, offset, 1);
		var profile_idc = Number(hex[0]);

		console.log("profile_idc: " + profile_idc);

		hex = new Uint8Array(data, offset + 2, 1);
		var level_idc = Number(hex[0]);

		console.log("level_idc: " + level_idc);

		var parseTemp = parseExpGolomb(rawData, bitOffset);
		var seq_parameter_set_id = parseTemp[0];
		bitOffset += parseTemp[1];

		console.log("seq_parameter_set_id: " + seq_parameter_set_id);

		if( profile_idc == 100 || profile_idc == 110 ||
			profile_idc == 122 || profile_idc == 244 || profile_idc == 44 ||
			profile_idc == 83 || profile_idc == 86 || profile_idc == 118 ||
			profile_idc == 128 || profile_idc == 138 || profile_idc == 139 ||
			profile_idc == 134 || profile_idc == 135 ) {

			parseTemp = parseExpGolomb(rawData, bitOffset);
			var chroma_format_idc = parseTemp[0];
			bitOffset += parseTemp[1];

			console.log("chroma_format_idc: " + chroma_format_idc);

			if( chroma_format_idc == 3 ){

				bitOffset += 1;

			}

			parseTemp = parseExpGolomb(rawData, bitOffset);
			var bit_depth_luma_minus8 = parseTemp[0];
			bitOffset += parseTemp[1];

			console.log("bit_depth_luma_minus8: " + bit_depth_luma_minus8);

			parseTemp = parseExpGolomb(rawData, bitOffset);
			var bit_depth_chroma_minus8 = parseTemp[0];
			bitOffset += parseTemp[1];

			console.log("bit_depth_chroma_minus8: " + bit_depth_chroma_minus8);

			//Todo check scaling matrix present flag

			bitOffset += 1;
			seq_scaling_matrix_present_flag =  readBits(rawData, bitOffset, 1)
			bitOffset += 1;

			if(seq_scaling_matrix_present_flag==1){
				console.log("seq_scaling_matrix_present_flag is true");

				var scaling_list_loop = 0;
				if(chroma_format_idc != 3){
					scaling_list_loop = 8;
				}else{
					scaling_list_loop = 12;
				}

				console.log("Skipping scaling list bits: " + scaling_list_loop);

				bitOffset += scaling_list_loop;

			}

		}

		if(profile_idc == 0) profile_idc = "Unknown";
		if(profile_idc == 66) profile_idc = "Baseline";
		if(profile_idc == 77) profile_idc = "Main";
		if(profile_idc == 88) profile_idc = "Extended";
		if(profile_idc == 100) profile_idc = "High";
		if(profile_idc == 122) profile_idc = "422";
		if(profile_idc == 110) profile_idc = "High10";
		if(profile_idc == 144) profile_idc = "444";
		if(profile_idc == 83) profile_idc = "ScalableBase";
		if(profile_idc == 86) profile_idc = "MultiviewHigh";
		if(profile_idc == 118) profile_idc = "MultiviewHigh";
		if(profile_idc == 128) profile_idc = "StereoHigh";
		if(profile_idc == 256) profile_idc = "ConstrainedBase";
		if(profile_idc == 257) profile_idc = "UCConstrainedHigh";
		if(profile_idc == 258) profile_idc = "UCScalableConstrainedBase";
		if(profile_idc == 259) profile_idc = "UCScalableConstrainedHigh";

		console.log("h264 info: " + profile_idc +" Profile, level " + level_idc/10);

		h264Profile = profile_idc + " Profile";
		h264Level = "" + level_idc/10;

		parseTemp = parseExpGolomb(rawData, bitOffset);
		var log2_max_frame_num_minus4 = parseTemp[0];
		bitOffset += parseTemp[1];

		console.log("log2_max_frame_num_minus4: " + log2_max_frame_num_minus4);

		parseTemp = parseExpGolomb(rawData, bitOffset);
		var pic_order_cnt_type = parseTemp[0];
		bitOffset += parseTemp[1];

		console.log("pic_order_cnt_type: " + pic_order_cnt_type);

		if( pic_order_cnt_type == 0 ){

			parseTemp = parseExpGolomb(rawData, bitOffset);
			var log2_max_pic_order_cnt_lsb_minus4 = parseTemp[0];
			bitOffset += parseTemp[1];

			console.log("log2_max_pic_order_cnt_lsb_minus4: " + log2_max_pic_order_cnt_lsb_minus4);

		}
		if( pic_order_cnt_type == 1 ){

			bitOffset += 1;
			parseTemp = parseExpGolomb(rawData, bitOffset);
			var offset_for_non_ref_pic = parseTemp[0];
			bitOffset += parseTemp[1];

			console.log("offset_for_non_ref_pic: " + offset_for_non_ref_pic);

			parseTemp = parseExpGolomb(rawData, bitOffset);
			var offset_for_top_to_bottom_field = parseTemp[0];
			bitOffset += parseTemp[1];

			console.log("offset_for_top_to_bottom_field: " + offset_for_top_to_bottom_field);

			parseTemp = parseExpGolomb(rawData, bitOffset);
			var num_ref_frames_in_pic_order_cnt_cycle = parseTemp[0];
			bitOffset += parseTemp[1];

			console.log("num_ref_frames_in_pic_order_cnt_cycle: " + num_ref_frames_in_pic_order_cnt_cycle);

			for( var f = 0; f < num_ref_frames_in_pic_order_cnt_cycle; f++ ){
				parseTemp = parseExpGolomb(rawData, bitOffset);
				var offset_for_ref_frame = parseTemp[0];
				bitOffset += parseTemp[1];

				console.log("offset_for_ref_frame "+f+": " + offset_for_ref_frame);
			}
		}

		parseTemp = parseExpGolomb(rawData, bitOffset);
		var num_ref_frames = parseTemp[0];
		bitOffset += parseTemp[1];

		console.log("num_ref_frames: " + num_ref_frames);

		h264RefFrames = "" + num_ref_frames;
	}

   function parseH264Frames(samples) {

       //console.log(samples);

       var sampleSizes = samples[1];
       var ptss = samples[2];
       var samples = samples[0];

       frameList = [];

	   var seqDataFound = false;

       for (var i = 0; i < samples.length; i++) {

           var _offset = 0;

		   var frameFound = false;

		   while (_offset < sampleSizes[i]) {

			   var hex = new Uint8Array(data, samples[i] + _offset + 4, 1);
               var nalSize = new DataView(data).getUint32(samples[i] + _offset);

               var nalUnitType = Number(hex[0] & 0x1F);

               if (nalUnitType == 6) {
                   parseSEIData(samples[i] + _offset);
               }

			   if (nalUnitType == 7 && !seqDataFound) {
					seqDataFound = true;
					console.log("Found seq parameter set NAL in bitstream at " + (samples[i] + _offset + 5));
					parseSeqParameterSetRbsp(samples[i] + _offset + 5);
               }

			   /*if (nalUnitType == 8) {
                   parsePicParameterSetRbsp(samples[i] + _offset + 5);
               }*/

               if (nalUnitType > 0 && nalUnitType < 6 && !frameFound) {
					frameFound = true;
                   var headerData = parseSliceHeader(samples[i] + _offset + 5);
                   frameList.push({
                       keyFrame: nalUnitType == 5,
                       streamOrder: i,
					   startOffset: samples[i],
                       size: sampleSizes[i],
                       frameType: headerData.frameType,
                       pts: ptss[i]
                   });
               }

			   _offset += nalSize + 4;
           }
       }

	   if(!seqDataFound && avcCspsStart != 0){
		console.log("No seq parameter set found, but was in avcC box at "+avcCspsStart+". Reading from that.");
		parseSeqParameterSetRbsp(avcCspsStart);
	   }

   }

   var timeScale = 0;
   function parseTimeScale(mdhd){
       if(mdhd != undefined){
	       atomversion = new DataView(data).getUint8(mdhd.offset + 8);
		   console.log("mdhd version: " + atomversion);
		   timescaleOffset = 8+4+8+8;
		   if(atomversion!=1){ //If version is 1 then date and duration is 8 bytes long, else 4 bytes
		       timescaleOffset = 8+4+4+4
		   }
		   timeScale = new DataView(data).getUint32(mdhd.offset + timescaleOffset);
	   }
	   console.log("timescale: " + timeScale);
   }

   function getSampleInfo(stsz, stco, stsc, stts, ctts) {

       var samplesPerChunk = [];
       var chunkStarts = [];
       var sampleStarts = [];
       var sampleSizes = [];
       var sampleDeltas = [];
       var samplePtss = [];

       //Read samples per chunk info
       var blocks = new DataView(data).getUint32(stsc.offset + 12);

       for (var i = 0; i < blocks; i++) {
           var firstChunk = new DataView(data).getUint32(stsc.offset + 16 + (12 * (i)));
           var nextFirst = 0;
           var nrChunks = 1;
           if (i + 1 < blocks) {
               nextFirst = new DataView(data).getUint32(stsc.offset + 16 + (12 * (i + 1)));
               nrChunks = nextFirst - firstChunk;
           }

           var _samplesPerChunk = new DataView(data).getUint32(stsc.offset + 20 + (12 * (i)));

           for (var j = 0; j < nrChunks; j++) {
               samplesPerChunk.push(_samplesPerChunk);
           }
       }

       //Read Chunk starts (stco)

       var chunks = new DataView(data).getUint32(stco.offset + 12);

       for (var i = 0; i < chunks; i++) {
           chunkStarts.push(new DataView(data).getUint32(stco.offset + 16 + (4 * i)));
       }

       //Read Sample starts (stsz)

       var samples = new DataView(data).getUint32(stsz.offset + 16);

       var sampleChunk = 0;
       var sampleLocation = 0;
       var used = 0;
       var sampleSizeAcc = 0;
       for (var i = 0; i < samples; i++) {
           //Figure out which chunk this sample is in
           used++;

           if (used > samplesPerChunk[sampleChunk]) {
               if (sampleChunk + 1 < samplesPerChunk.length) {
                   sampleChunk++;
               }
               sampleLocation++;
               used = 1;
               sampleSizeAcc = 0;
           }

           var _sampleSize = new DataView(data).getUint32(stsz.offset + 20 + (i * 4));

           sampleStarts.push(chunkStarts[sampleLocation] + sampleSizeAcc);
           sampleSizes.push(_sampleSize);
           sampleSizeAcc += _sampleSize;
       }

       //console.log(sampleStarts);

       //Read sample delta values

       var sttsEntries = new DataView(data).getUint32(stts.offset + 12);

       for (var i = 0; i < sttsEntries; i++) {
           var sampleCount = new DataView(data).getUint32(stts.offset + 16 + (8 * i));
           var sampleDelta = new DataView(data).getUint32(stts.offset + 20 + (8 * i));
           for (var j = 0; j < sampleCount; j++) {
               sampleDeltas.push(sampleDelta);
           }
       }

       //Parse PTS from ctts+stts

       var currentTimeStamp = 0;
       var currentSample = -1;
       if (ctts!= undefined){
           var cttsEntries = new DataView(data).getUint32(ctts.offset + 12);
       }
       var startOffset = 0;

       if(ctts != undefined){
           for (var i = 0; i < cttsEntries; i++) {
               var sampleCount = new DataView(data).getUint32(ctts.offset + 16 + (8 * i));
               var sampleOffset = new DataView(data).getInt32(ctts.offset + 20 + (8 * i));
               for (var j = 0; j < sampleCount; j++) {
                   currentSample++;
                   if (i == 0 && j == 0) {
                       startOffset = sampleOffset;
                   }
                   samplePtss.push(currentTimeStamp + sampleDeltas[currentSample] + sampleOffset - startOffset);
                   currentTimeStamp += sampleDeltas[currentSample];
               }
           }
       }
       else{
           for (var i = 0; i < sampleDeltas.length; i++){
               samplePtss.push(currentTimeStamp + sampleDeltas[i]);
               currentTimeStamp+=sampleDeltas[i];
           }
       }

       return [sampleStarts, sampleSizes, samplePtss];

   }

   var mddatEnd = 0;
   var avcCspsStart = 0;

   function listAtoms(startOffset, endOfFile, level) {
       var atoms = [];

       var localLevel = level;

       var localOffset = startOffset;

       while (localOffset < endOfFile) {
           var currentAtomOffset = localOffset;
		   var boxSize = new DataView(data).getUint32(currentAtomOffset);
           localOffset = localOffset + boxSize;
           atomname = u8toString(new Uint8Array(data, currentAtomOffset + 4, 4));
           atoms.push({
               offset: currentAtomOffset,
               name: atomname,
               level: localLevel
           });

		   if(atomname == "mdat"){
				if(localOffset==(currentAtomOffset + 1)){
					console.log("Detecting 64 bit mdat offset");
					console.log("Mdat size: "+ (((new DataView(data).getUint32(startOffset+8))+1) * (new DataView(data).getUint32(startOffset+12))));
					localOffset = startOffset + (((new DataView(data).getUint32(startOffset+8))+1) * (new DataView(data).getUint32(startOffset+12)));
				}
				mddatEnd = localOffset;
		   }else if (atomname == "moov" ||
               atomname == "trak" ||
               atomname == "mdia" ||
               atomname == "minf" ||
               atomname == "stbl") {
               console.log("Found "+atomname+", going deeper");
               atoms = atoms.concat(listAtoms(currentAtomOffset + 8, localOffset, localLevel + 1));
           }
           else if(atomname == "stsd"){
               console.log("Found "+atomname+", handle with care");
			   atoms = atoms.concat(listAtoms(currentAtomOffset + 16, localOffset, localLevel + 1));
           }
		   else if(atomname == "avc1"){
               console.log("Found "+atomname+", handle with care");
			   pixelWidth = new DataView(data).getUint16(currentAtomOffset+32);
			   pixelHeight = new DataView(data).getUint16(currentAtomOffset+34);
			   atoms = atoms.concat(listAtoms(currentAtomOffset + 86, localOffset, localLevel + 1));
           }
		   else if(atomname == "avcC"){
               console.log("Found "+atomname+", handle with care");
			   avcCspsStart = currentAtomOffset+16+1;

			   //Extract config for decoder
			   seqParamSet = new Uint8Array(data, avcCspsStart-1-8, boxSize);
			   console.log(seqParamSet);
			   console.log("Found sequence parameter set NAL at " + avcCspsStart);
           }

       }

       console.log("All done with atoms");

       return atoms;

   }

   function parseMp4() {

       if (data.byteLength < 8 ||
           !(u8toString(new Uint8Array(data, 4, 4)) == "ftyp")
       ) {
           console.log("Not an MP4 file");
           chartContainer.innerHTML="<center><p style=\"color:red;\">Not recognized as MP4 file<p><center>"
           return false;
       }

       var atoms = [];

       var offset = new DataView(data).getUint32(0);
       var atomname = u8toString(new Uint8Array(data, 4, 4));

       atoms.push({
           offset: offset,
           name: atomname,
           level: 0
       });

       var majorBrand;
       var majorBrandVersion;
       var compatibleBrands = [];

       majorBrand = u8toString(new Uint8Array(data, 8, 4));
       majorBrandVersion = new DataView(data).getUint32(12);

       for (var i = 16; i < offset; i = i + 4) {
           compatibleBrands.push(u8toString(new Uint8Array(data, i, 4)));
       }

       console.log("Major Brand: " + majorBrand);
       console.log("Major Brand Version: " + majorBrandVersion);

       for (var i = 0; i < compatibleBrands.length; i++) {
           console.log("Compatible Brand: " + compatibleBrands[i]);
       }

       atoms = atoms.concat(listAtoms(offset, data.byteLength, 0));



       for (var i = 0; i < atoms.length; i++) {
           var localLevel = atoms[i].level;
           var levelIndicator = "";
           for (var j = 0; j < localLevel; j++) {
               levelIndicator = levelIndicator + "-";
           }
           console.log(levelIndicator + "[" + atoms[i].name + "]");

       }

       var avc1 = false;
       var avcTrack = 0;
       for (var i = 0; i<atoms.length; i++){
           if(atoms[i].name=="trak"){
               avcTrack=i;
           }
           if(atoms[i].name=="avc1"){
               avc1=true;
               break;
           }
       }

	   for (var i = avcTrack; i<avcTrack+3; i++){
			if(atoms[i].name=="tkhd"){
					console.log("Found "+atomname+", trying to parse aspect ratio");
					const width = new DataView(data).getUint32(atoms[i].offset + 84);
					const tkhdwidth = createHexString(new Uint8Array(data, atoms[i].offset + 80, 16));
					console.log(tkhdwidth);
					console.log("Width: " + width);
					const height = new DataView(data).getUint32(atoms[i].offset + 88);
					console.log("Height: " + height);
					aspect = width/height;
					break;
			}
	   }

       if(avc1 == false){
           console.log("Could not find h264 track");
           chartContainer.innerHTML="<center><p style=\"color:red;\">No h264 track found<p><center>"
           return false;
       }

       var stsz, stco, stsc, stts, ctts, mdhd;
       for (var j = avcTrack+1; j < atoms.length; j++) {
           if (atoms[j].level <= atoms[avcTrack].level) {
               break;
           }
           if (atoms[j].name == "stsz") stsz = atoms[j];
           if (atoms[j].name == "stco") stco = atoms[j];
           if (atoms[j].name == "stsc") stsc = atoms[j];
           if (atoms[j].name == "stts") stts = atoms[j];
           if (atoms[j].name == "ctts") ctts = atoms[j];
		   if (atoms[j].name == "mdhd") mdhd = atoms[j];
       }
       if (stsz == undefined || stco == undefined || stsc == undefined || stts == undefined) {
           console.log("Could not find correct atoms for track");
           chartContainer.innerHTML="<center><p style=\"color:red;\">Avc track is missing importans atoms/boxes<p><center>"
           return false;
       } else {
	       console.log(mdhd);
	       parseTimeScale(mdhd);
           if (ctts == undefined){
               console.log("No ctts atom found. Baseline? Or just missing")
           }
           var samples = getSampleInfo(stsz, stco, stsc, stts, ctts);
           parseH264Frames(samples);
           frameList.sort(sortByPts);
		   gopSize = calculateGOPsize();
		   extraKeyFrames = findExtraKeyframes();
           drawVideoChart(frameList);

		   gtag('event', 'draw_video_chart', {
			  'event_category' : 'engagement',
			  'event_label' : 'Show Frame Graph'
			});
       }
   }

   // Get file data on drop
   dropZone.addEventListener('drop', function(e) {

       chartContainer.innerHTML="<center><p>Loading...</p></center>";

       SEI="";
       SEIContainer.innerHTML="";
	   h264Profile = "";
	   h264Level = "";
	   h264RefFrames = "";
	   avcCspsStart = 0;
	   gopSize = -1;
	   extraKeyFrames = [];

       e.stopPropagation();
       e.preventDefault();
       var files = e.dataTransfer.files; // Array of all files
       for (var i = 0, file; file = files[i]; i++) {

			gtag('event', 'drop_file', {
			  'event_category' : 'engagement',
			  'event_label' : 'Drop file on page'
			});

           //if (file.type.match(/image.*/)) {
           var reader = new FileReader();

		   reader.addEventListener('progress', event => {
				let percentage = Math.floor((event.loaded / event.total) * 100);
				chartContainer.innerHTML="<center><p>Loading " + percentage + "%</p></center>";
				if(percentage>95)chartContainer.innerHTML="<center><p>Calculating..</p></center>";
		   });

		   reader.addEventListener('error', event => { console.log(event); chartContainer.innerHTML="<center><h1>Error. File too big? (>2GB?)</h1></center>";});

		   console.log(file);

		   title.innerHTML = file.name;

           reader.onload = function(e2) { // finished reading file data.
			   data = e2.target.result;
               parseMp4();
			   initdecoder();
           }
           reader.readAsArrayBuffer(file); // start reading the file data.
           //}
       }


   });
</script>
    </body>
</html>
